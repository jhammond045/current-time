<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Mandala</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #fff9db; /* Faint yellow background */
        }
        canvas {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="mandalaCanvas" width="800" height="800"></canvas>
    <script>
        let currentMandala = [];
        let nextMandala = [];
        let animating = false;
        let animationStartTime;
        const animationDuration = 2000; // 2 seconds

        function drawCircle(ctx, centerX, centerY, radius, alpha = 1) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            ctx.strokeStyle = `rgba(101, 67, 33, ${alpha})`; // Dark brown color with alpha
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function generateMandala(numCircles, baseRadius, canvasWidth, canvasHeight) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            const mandala = [];
            const angleStep = 2 * Math.PI / numCircles;

            for (let i = 0; i < numCircles; i++) {
                const angle = i * angleStep;
                const radius = baseRadius * (Math.random() * (1.5 - 0.5) + 0.5);
                const circleRadius = baseRadius * (Math.random() * (1.5 - 0.5) + 0.5);
                const circleCenterX = centerX + radius * Math.cos(angle);
                const circleCenterY = centerY + radius * Math.sin(angle);

                mandala.push({ x: circleCenterX, y: circleCenterY, r: circleRadius });
                mandala.push({ x: centerX - (circleCenterX - centerX), y: circleCenterY, r: circleRadius });
                mandala.push({ x: circleCenterX, y: centerY - (circleCenterY - centerY), r: circleRadius });
                mandala.push({ x: centerX - (circleCenterX - centerX), y: centerY - (circleCenterY - centerY), r: circleRadius });
            }
            return mandala;
        }

        function drawMandala(ctx, mandala, alpha = 1) {
            for (const circle of mandala) {
                drawCircle(ctx, circle.x, circle.y, circle.r, alpha);
            }
        }

        function morphMandala(ctx, startTime) {
            const currentTime = Date.now();
            const elapsedTime = currentTime - startTime;

            if (elapsedTime >= animationDuration) {
                currentMandala = nextMandala;
                animating = false;
                return;
            }

            const alpha = elapsedTime / animationDuration;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            drawMandala(ctx, currentMandala, 1 - alpha);
            drawMandala(ctx, nextMandala, alpha);

            requestAnimationFrame(() => morphMandala(ctx, startTime));
        }

        function startMorphing(ctx, numCircles, baseRadius, canvasWidth, canvasHeight) {
            nextMandala = generateMandala(numCircles, baseRadius, canvasWidth, canvasHeight);
            animating = true;
            animationStartTime = Date.now();
            requestAnimationFrame(() => morphMandala(ctx, animationStartTime));
        }

        window.onload = () => {
            const canvas = document.getElementById('mandalaCanvas');
            const ctx = canvas.getContext('2d');
            const numCircles = 3;
            const baseRadius = 50;
            currentMandala = generateMandala(numCircles, baseRadius, canvas.width, canvas.height);
            drawMandala(ctx, currentMandala);

            setInterval(() => {
                if (!animating) {
                    startMorphing(ctx, numCircles, baseRadius, canvas.width, canvas.height);
                }
            }, 2000); // Change every 10 seconds
        };
    </script>
</body>
</html>
